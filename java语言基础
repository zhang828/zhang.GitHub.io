1、 面向对象和面向过程的区别
面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。
面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。
2、Java 语言有哪些特点?
1.简单易学；
2.面向对象（封装，继承，多态）；
3.平台无关性（ Java 虚拟机实现平台无关性）；
4.可靠性；
5.安全性；
6.支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
7.支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；
8.编译与解释并存；
3、JVM、JDK 、JRE
JVM：Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。
什么是字节码?采用字节码的好处是什么?
在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。
一次编译 到处运行
Java 程序从源代码到运行一般有下面3步：
　　
　　我们需要格外注意的是 .class->机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。
 JDK：（Java Development Kit）Java开发工具包，它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。
JRE：（Java Runtime Environment）Java运行时环境，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。
4、Java和C++的区别?
JAVA和C++都是面向对象语言。也就是说，它们都能够实现面向对象思想（封装，继乘，多态）。而由于c++为了照顾大量的C语言使用者，而兼容了C，使得自身仅仅成为了带类的C语言，多多少少影响了其面向对象的彻底性！JAVA则是完全的面向对象语言，它句法更清晰，规模更小，更易学。它是在对多种程序设计语言进行了深入细致研究的基础上，摒弃了其他语言的不足之处，从根本上解决了c++的固有缺陷。
1 都是面向对象的语言，都支持封装、继承和多态。
2 Java 不提供指针来直接访问内存，程序内存更加安全。
JAVA语言让编程者无法找到指针来直接访问内存无指针，并且增添了自动的内存管理功能，从而有效地防止了c／c++语言中指针操作失误，如野指针所造成的系统崩溃。但也不是说JAVA没有指针，虚拟机内部还是使用了指针，只是外人不得使用而已。这有利于Java程序的安全。
3 Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
c++支持多重继承，这是c++的一个特征，它允许多父类派生一个类。尽管多重继承功能很强，但使用复杂，而且会引起许多麻烦，编译程序实现它也很不容易。Java不支持多重继承，但允许一个类继承多个接口(extends+implement)，实现了c++多重继承的功能，又避免了c++中的多重继承实现方式带来的诸多不便。
4 Java 有自动内存管理机制，不需要程序员手动释放无用内存。
程序的运行必然需要申请内存资源，无效的对象资源如果不及时处理就会一直占有内存 资源，最终将导致内存溢出，所以对内存资源的管理是非常重要了。
在C++语言中，没有自动垃圾回收机制，是通过new关键字申请内存资源，通过delete 关键字释放内存资源。
如果，程序员在某些位置没有写delete进行释放，那么申请的对象将一直占用内存资源， 最终可能会导致内存溢出。
在C++语言中，需要开发人员去管理内存的分配（包括申请和释放），而Java语言提供了垃圾回收器来实现垃圾的自动回收，不需要程序显示地管理内存的分配。在C++语言中，通常会把释放资源的代码放到析构函数中，Java语言中虽然没有析构函数，但却引入了一个finalize()方法，当垃圾回收器要释放无用对象的内存时，会首先调用该对象的finalize()方法，因此，开发人员不需要关心也不需要知道对象所占的内存空间何时被释放。
为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC。
有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。
换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致 内存资源一直没有释放，同样也可能会导致内存溢出的。
当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。
5．数据类型及类
Java是完全面向对象的语言，所有函数和变量都必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而c++允许将函数和变量定义为全局的。
6.异常
JAVA中的异常机制用于捕获例外事件，增强系统容错能力
try{／／可能产生例外的代码
}catch(exceptionType name){
//处理
}
其中exceptionType表示异常类型。而C++则没有如此方便的机制。
7．类型转换
在c和c十十中有时出现数据类型的隐含转换，这就涉及了自动强制类型转换问题。例如，在c十十中可将一浮点值赋予整型变量，并去掉其尾数。Java不支持c十十中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。
8．操作符重载
Java不支持操作符重载。操作符重载被认为是c十十的突出特征，在Java中虽然类大体上可以实现这样的功能，但操作符重载的方便性仍然丢失了不少。Java语言不支持操作符重载是为了保持Java语言尽可能简单。
9．预处理功能
Java不支持预处理功能。c／c十十在编译过程中都有一个预编泽阶段，即众所周知的预处理器。预处理器为开发人员提供了方便，但增加了编译的复杂性。JAVA虚拟机没有预处理器，但它提供的引入语句(import)与c十十预处理器的功能类似。
10. Java不支持缺省函数参数，而c十十支持
在c中，代码组织在函数中，函数可以访问程序的全局变量。c十十增加了类，提供了类算法，该算法是与类相连的函数，c十十类方法与Java类方法十分相似，然而，由于c十十仍然支持c，所以不能阻止c十十开发人员使用函数，结果函数和方法混合使用使得程序比较混乱。
Java没有函数，作为一个比c十十更纯的面向对象的语言，Java强迫开发人员把所有例行程序包括在类中，事实上，用方法实现例行程序可激励开发人员更好地组织编码。
11、Java为解释性语言，其运行过程为：程序源代码经过Java编译器编译成字节码，然后由JVM解释执行。而C/C++为编译型语言，源代码经过编译和链接后生成可执行的二进制代码，可直接执行。因此Java的执行速度比C/C++慢，但Java能够跨平台执行，C/C++不能。
其他
1>Java具有平台无关性，即对每种数据类型都分配固定长度的空间，例如int型总是占据32位；而C/C++不然，同一个数据类型在不同平台上会分配不同的字节数。
2>Java提供对注释文档的内建支持，所以源码文件也可以包含它们自己的文档。通过一个单独的程序，这些文档可以提取出来，并重新格式化为HTML。
3>Java包含了一些标准库，用于完成特定的任务，同时这些库简单易用，能够大大缩短开发周期。例如，Java提供了用于访问数据库的JDBC库，用于实现分布式对象的RMI等标注库。C++则依靠一些非标准的、由其他厂商提供的库。
还有一点可以谈谈


5、8大基本数据类型及其字节数？
byte：1字节　　　　short：2字节
int：4字节　　　　long：8字节
float：4字节精确到7位有效数字　　　　double：8字节
char：2字节　　　　boolean：1位
引用类型：4字节 ，1个字节表示8位
6、构造器 Constructor 是否可被 override?
　　 父类的私有属性和构造方法并不能被继承，所以 Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。
7、重载和重写的区别？
重载： 发生在同一个类中，方法名必须相同，实质表现就是多个具有不同的参数个数或者类型的同名函数（返回值类型可随意，不能以返回类型作为重载函数的区分标准），返回值类型、访问修饰符可以不同，发生在编译时。 　　
重写： 发生在父子类中，方法名、参数列表必须相同，是父类与子类之间的多态性，实质是对父类的函数进行重新定义。返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。
 问：Java 构造方法能否被重写和重载？
　　重写是子类方法重写父类的方法，重写的方法名不变，而类的构造方法名必须与类名一致，假设父类的构造方法如果能够被子类重写则子类类名必须与父类类名一致才行，所以 Java 的构造方法是不能被重写的。而重载是针对同一个的，所以构造方法可以被重载。
8、Java 面向对象编程三大特性？
　　封装 继承 多态
 封装：
　　封装就是把抽象的数据和对数据进行的操作封装在一起，数据被保存在内部，程序的其他部分只有通过被授权的操作（成员方法）才能对数据进行操作。
　　java提供了四种控制修饰符控制方法和变量访问的权限：
public：对外公开
protected：对子类和同一包中的类公开
没有修饰符号：向同一个包的类公开
private：只有类本身可以访问，不对外公开
 继承：（extends ）
　　继承是使用已存在的类的定义作为基础建立新类的技术。继承可以解决代码复用问题，当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extend语句来声明继承父类。
关于继承如下 3 点请记住：
子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
子类可以用自己的方式实现父类的方法。
多态：
所谓多态，就是指一个引用（类型）在不同情况下的多种状态，你也可以这样理解：父类型的引用指向子类型的对象。
多态指同一个实体同时具有多种形式。它是面向对象程序设计（OOP）的一个重要特征。如果一个语言只支持类而不支持多态，只能说明它是基于对象的，而不是面向对象的。
* 多态是出现在具有继承关系的两个类的对象之间，所以它不像方法重载（发生在一个类中）在编译期间发生（也就是确定下来），而是在运行期间发生（确定下来）。*

一个父类类型的引用可以指向他任何一个子类的对象
[相同]类域的[不同]对象执行[同一]方法的时候会有[不同]的表现
有一个比较经典的多态实例：
有一个Animal类，它有Cat，和Dog两个子类，在Animal中有个say方法，当Cat调用这个方法的时候输出的是“小猫喵喵喵”，当Dog调用这个方法时，输出的是“小狗汪汪汪”，这就是Java多态的实现。
多态有两个好处：
1.应用程序不必为每一个派生类编写功能调用，只需要对抽象基类进行处理即可。大大提高程序的可复用性。//继承 
2. 派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。 //多态的真正作用，
9、String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?（重要）
一、区别
1、String是字符串常量，而StringBuffer和StringBuilder是字符串变量。由String创建的字符内容是不可改变的，而由StringBuffer和StringBuidler创建的字符内容是可以改变的。
2、StringBuffer是线程安全的，而StringBuilder是非线程安全的。StringBuilder是从JDK 5开始，为StringBuffer类补充的一个单线程的等价类。我们在使用时应优先考虑使用StringBuilder，因为它支持StringBuffer的所有操作，但是因为它不执行同步，不会有线程安全带来额外的系统消耗，所以速度更快。
二、String为什么是不可变的？
String 类中使用 final 关键字修饰字符数组来保存字符串，private　final　char　value[]，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。
　　String是被声明为final class，除了hash这个属性其它属性都声明为final。因为它的不可变性，所以例如拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。
　　StringBuffer就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类，提供append和add方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列，把所有修改数据的方法都加上了synchronized。但是保证了线程安全是需要性能的代价的。
　　在很多情况下我们的字符串拼接操作不需要线程安全，这时候StringBuilder登场了，StringBuilder是JDK1.5发布的，它和StringBuffer本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。
　　StringBuffer 和 StringBuilder 二者都继承了 AbstractStringBuilder ，底层都是利用可修改的char数组(JDK 9 以后是 byte数组)。
再说说字符串常量池：
　　Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池。
　　创建一个字符串时，首先会检查池中是否有值相同的字符串对象，如果有就直接返回引用，不会创建字符串对象；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的String对象是不检查字符串常量池的，而是直接在堆中创建新对象，也不会把对象放入池中。上述原则只适用于直接给String对象引用赋值的情况。
　　String str1 = new String("a");  //不检查字符串常量池的
　　String str2 = "bb";   //检查字符串常量池的
　　String还提供了intern()方法。调用该方法时，如果字符串常量池中包括了一个等于此String对象的字符串（由equals方法确定），则返回池中的字符串的引用。否则，将此String对象添加到池中，并且返回此池中对象的引用。
　　在JDK6中，不推荐大量使用intern方法，因为这个版本字符串缓存在永久代中，这个空间是有限了，除了FullGC之外不会被清除，所以大量的缓存在这容易OutOfMemoryError。
　　之后的版本把字符串放入了堆中，避免了永久代被挤满。
参考：https://baijiahao.baidu.com/s?id=1629804867201303563&wfr=spider&for=pc
对于三者使用的总结：
1.操作少量的数据: 适用String
2.单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder
3.多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer
 请解释一下String为什么不可变？
考察点：面向对象
不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。
String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。
10、自动装箱与拆箱
装箱：将基本类型用它们对应的引用类型包装起来；
拆箱：将包装类型转换为基本数据类型；
//自动装箱
Integer total = 99; //系统自动执行了Integer total = Integer.valueOf(99);
 //自定拆箱int totalprim = total;  //系统自动执行了int totalprim = total.intValue();
问题一：int和Integer的区别？
1. int是基本数据类型，Integer是int的包装类就是将int类型包装成Object对象；
2. Integer变量必须实例化后才能使用；int变量不需要；
3. Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；
4. Integer的默认值是null；int的默认值是0。
深入：
两个通过new生成的Integer变量永远是不相等的。因为new生成的是两个对象，其内存地址不同。
Integer与new Integer不会相等。因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同。
 两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false。
 java在编译Integer i = 127的时候,被翻译成 Integer i = Integer.valueOf(127);  java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127这个Integer对象进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。（享元模式）
Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true。（因为包装类Integer和基本数据类型int比较时，java会自动拆箱为int，然后进行比较，实际上就变为两个int变量的比较）
Integer.valueOf函数源码：
public static Integer valueOf(int i) {
    return  i >= 128 || i < -128 ? new Integer(i) : SMALL_VALUES[i + 128];
}
它会首先判断i的大小：如果i小于-128或者大于等于128，就创建一个Integer对象，否则执行SMALL_VALUES[i + 128]。
SMALL_VALUES[i + 128]是什么东西：
private static final Integer[] SMALL_VALUES = new Integer[256];
SMALL_VALUES本来已经被创建好，也就是说在i >= 128 || i < -128是会创建不同的对象，在i < 128 && i >= -128会根据i的值返回已经创建好的指定的对象。
问题二：为什么有了int还要有设计Integer？
　　对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据。
　　另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。
11、为什么不能从静态的方法里调用非静态的方法或变量？
　　非静态的方法可以调用静态的方法，但是静态的方法不可以调用非静态的方法。
　　类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。
　　在一个类的静态成员中去访问其非静态成员之所以会出错是因为在类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。
参考https://blog.csdn.net/l18649805795/article/details/48939487
12、静态方法和实例方法有何不同？
在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。
问题：static修饰变量、代码块时什么时候执行？执行几次？
　　在类加载的init阶段，类的类构造器中会收集所有的static块和字段并执行；static块只执行一次。
【注】：
static语句块,不是在实例化的时候被执行的；
在调用类中任何一个方法时，jvm进行类加载，static语句块是在类加载器加载该类的最后阶段进行初始化的。并且只会被初始化一次。  （注：若一次性调用多个方法，则只会执行一次static代码块。）
13、在 Java 中定义一个不做事且没有参数的构造方法的作用？
　　Java 程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。
问题：子类继承父类时，父类的构造方法什么时候调用？
　　实例化一个子类对象时会先执行其父类的构造函数，然后再执行子类的构造函数。
　　super()必须先被调用；如果子类构造方法里没有写super()，编译器会自动调用super()方法，即调用父类的默认无参构造方法。所以不可以父类中只定义了有参数的构造方法（在Java中，如果一个类没有定义构造方法，编译器会默认插入一个无参数的构造方法；但是如果一个构造方法在父类中已定义，在这种情况，编译器是不会自动插入一个默认的无参构造方法）
14、构造方法有哪些特性？
1.名字与类名相同。
2.没有返回值，但不能用void声明构造函数。
3.生成类的对象时自动执行，无需调用。
15、接口（interface）和抽象类（abstract class）的区别是什么？
1.接口中的所有方法必须都是抽象的，不能有非抽象的普通方法（所有方法在接口中不能有实现）；而抽象类中可以包含非抽象的普通方法。1.8有新特性
2.接口中不能有构造方法，抽象类可以有构造方法。
3.接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。
4.一个类可以实现多个接口，但只能继承一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
5.接口中的抽象方法只能是public类型的，并且默认修饰符是public；抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。
6.接口中不能包含静态方法；抽象类中可以包含静态方法。1.8有新特性
7.抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。
8.接口强调特定功能的实现，其设计理念是“has a”的关系，而抽象类强调所属关系，其设计理念是“is a”的关系。比如我们有老鹰和大雁这两个类，我们可以抽象出“鸟”这样一个抽象类，让这两个类继承他，还可以设置一个“飞”的接口，让这两个类实现他。
接口中可以定义默认实现方法和静态方法
在接口中可以使用default和static关键字来修饰接口中定义的普通方法

在JDK1.8中很多接口会新增方法，为了保证1.8向下兼容，1.7版本中的接口实现类不用每个都重新实现新添加的接口方法，引入了default默认实现，static的用法是直接用接口名去调方法即可。当一个类继承父类又实现接口时，若后两者方法名相同，则优先继承父类中的同名方法，即“类优先”，如果实现两个同名方法的接口，则要求实现类必须手动声明默认实现哪个接口中的方法。

接口和抽象类的相同点：
1.都不能被实例化
2.接口的实现类或者抽象的子类都只有实现了接口或者抽象类中的方法才能被实例化。
16、成员变量与局部变量的区别有那些？
1.从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。
2.从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
3.从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4.成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。
17、== 与 equals的区别？（重要）
　　1）==比较的是值是否相等
       　　如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；
　　　　如果作用于引用类型的变量，则比较的是所指向的对象的地址。
　　2）equals方法不能作用于基本数据类型的变量，只能用于类变量。（对于基本数据类型要用其包装类）
　　　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；
　　　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。
【注】Object类中的equals方法和“==”是一样的，没有区别，而String类，Integer类等等一些类，是重写了equals方法，才使得equals和“==不同”，所以，当自己创建类时，自动继承了Object的equals方法，要想实现不同的等于比较，必须重写equals方法。

    String a = new String("ab");  // a为一个引用
    String b = new String("ab");  // b为另一个引用,对象的内容一样
    String aa = "ab";   //放在常量池中
    String bb = "ab";   //从常量池中查找        
    System.out.println(aa==bb);//true
    System.out.println(a==b); //false，非同一对象            
    System.out.println((a.equals(b)); //true            
    System.out.println((42 == 42.0); //true
String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。
18、为什么重写equals时必须重写hashCode方法？ (重要)
当对象的equals()方法被重写时，通常有必要重写 hashCode() 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。
          （1）两个对象相等，hashcode一定相等
          （2）两个对象不等，hashcode不一定不等
          （3）hashcode相等，两个对象不一定相等
          （4）hashcode不等，两个对象一定不等
          hashcode是用于散列数据的快速存取，如利用HashSet/HashMap/Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。这样如果我们对一个对象重写了euqals，意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象，当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致。
https://www.cnblogs.com/wang-meng/p/7501378.html
HashMap中的get与put：
（1）put：
              1.首先根据put元素的key获取hashcode，然后根据hashcode算出数组的下标位置，如果下标位置没有元素，直接放入元素即可。
              2.如果该下标位置有元素，则需要已有元素和put元素的key对象比较equals方法，如果equals不一样，则说明可以放入进map中，会在该数组位置创建一个链表，后put进入的元素到放链表头，原来的元素向后移动。       
（2）get：
             根据元素的key获取hashcode，然后根据hashcode获取数组下标位置，如果只有一个元素则直接取出。如果该位置是一个链表，则需要调用equals方法遍历链表中的所有元素与当前的元素比较,得到真正想要的对象。（当两个对象的hashcode不同的话，肯定他们不能equals。）
19、Java 中 final、finally、finalize 的区别？
（1） final 是一个修饰符，
1.如果一个类被声明为 final 则其不能再派生出新的子类，所以一个类不能既被声明为 abstract 又被声明为 final [所谓不可同时出现]的；
2.将变量或方法声明为 final 可以保证它们在使用中不被改变（对于对象变量来说其引用不可变，即不能再指向其他的对象，但是对象的值可变）。
　　　注：
1.被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改，被声明为 final 的方法也同样只能使用不能重载。
2.使用 final 关键字如果编译器能够在编译阶段确定某变量的值则编译器就会把该变量当做编译期常量来使用，如果需要在运行时确定（譬如方法调用）则编译器就不会优化相关代码；将类、方法、变量声明为 final 能够提高性能，这样 JVM 就有机会进行估计并进行优化；接口中的变量都是 public static final 的。
final关键字主要用在三个地方：变量、方法、类。
1.对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2.当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
3.使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。
1、被final修饰的类不可以被继承
2、被final修饰的方法不可以被重写
3、被final修饰的变量不可以被改变
被final修饰的变量，不管变量是在是哪种变量，切记不可变的是变量的引用而非引用指向对象的内容。
（2）finally：用来在异常处理中，如果抛出一个异常，则相匹配的 catch 子句就会执行，然后控制就会进入 finally 块
　　finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。
异常处理：
try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。
catch 块：用于处理try捕获到的异常。
finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。
在以下4种特殊情况下，finally块不会被执行：
1.在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行
2.在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行
3.程序所在的线程死亡。
4.关闭CPU。
（3）finalize()：是一个方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。
　　finalize()方法是GC运行机制的一部分，finalize()方法是在GC清理它所从属的对象时被调用的，如果执行它的过程中抛出了无法捕获的异常，GC将终止对该对象的清理，并且该异常会被忽略；直到下一次GC开始清理这个对象时，它的finalize()会被再次调用。
20、this、super
（1）this：代表对象本身，可以理解为：指向对象本身的一个指针。
this的用法在java中大体可以分为3种：
1）普通的直接引用
这种就不用讲了，this相当于是指向当前对象本身：
2）形参与成员名字重名，用this来区分：

3）引用构造函数
this（参数）：调用本类中另一种形式的构造方法（应该为构造方法中的第一条语句）
 
（2）super：代指父类，可以用于调用父类的普通方法和构造方法。
调用父类构造方法：super()(无参构造方法)或 super(参数)(有参构造方法)
调用父类普通方法：super.方法名(参数)
 
21、Java序列化中如果有些字段不想进行序列化，怎么办？
 　　对于不想进行序列化的变量，使用transient关键字修饰。
　　transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。
22、 获取用键盘输入常用的的两种方法
 方法1：通过 Scanner
Scanner sc = new Scanner(System.in);
String s  = sc.nextLine();
input.close();
方法2：通过 BufferedReader
BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); 
String s = input.readLine();
23 请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？
考察点：JAVA构造函数
当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。
Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。
Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。
24 static关键字
静态变量和静态方法
static关键字最基本的用法是：
1、被static修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要new出一个类来
2、被static修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要new出一个类来
被static修饰的变量、被static修饰的方法统一属于类的静态资源，是类实例之间共享的，换言之，一处变、处处变。JDK把不同的静态资源放在了不同的类中而不把所有静态资源放在一个类里面，很多人可能想当然认为当然要这么做，但是是否想过为什么要这么做呢？个人认为主要有三个好处：
1、不同的类有自己的静态资源，这可以实现静态资源分类。比如和数学相关的静态资源放在java.lang.Math中，和日历相关的静态资源放在java.util.Calendar中，这样就很清晰了
2、避免重名。不同的类之间有重名的静态变量名、静态方法名也是很正常的，如果所有的都放在一起不可避免的一个问题就是名字重复，这时候怎么办？分类放置就好了。
3、避免静态资源类无限膨胀，这很好理解。
静态资源属于类，但是是独立于类存在的。从JVM的类加载机制的角度讲，静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的。类的初始化早于类的new，比如Class.forName(“xxx”)方法，就是初始化了一个类，但是并没有new它，只是加载这个类的静态资源罢了。所以对于静态资源来说，它是不可能知道一个类中有哪些非静态资源的；但是对于非静态资源来说就不一样了，由于它是new出来之后产生的，因此属于类的这些东西它都能认识。所以上面的几个问题答案就很明确了：
1、静态方法能不能引用非静态资源？不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。
2、静态方法里面能不能引用静态资源？可以，因为都是类初始化的时候加载的，大家相互都认识。
3、非静态方法里面能不能引用静态资源？可以，非静态方法就是实例方法，那是new之后才产生的，那么属于类的内容它都认识。
 
静态块
静态块也是static的重要应用之一。也是用于初始化一个类的时候做操作用的，和静态变量、静态方法一样，静态块里面的代码只执行一次，且只在初始化类的时候执行。
静态资源的加载顺序是严格按照静态资源的定义顺序来加载的。这和周志明老师《深入理解Java虚拟机：JVM高级特性与最佳实践》中类初始化中的说法“<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的”是一致的。
静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。
静态代码块是严格按照父类静态代码块->子类静态代码块的顺序加载的，且只加载一次。
25请说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？
考察点：static变量
“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
27 静态变量存放在哪里？
静态变量存在方法区，Java 8 方法区已经没有了，取而代之的是元空间，元空间搬到了本地内存中
这个静态常量放在哪里,要看jdk版本的吧,jdk8之前是在方法区,从jdk8开始是放在堆里的吧
方法区是一种规范，而永久代是实现了方法区这个规范而存在的，是属于堆的逻辑空间，存储着类的元数据信息，静态变量，和运行时常量池，而1.8以后，将永久代取消，但是方法区这个规范还存在，多了个元空间实现方法区规范，属于本地内存存放类的元数据，常量池的引用，而常量池的实例数据存储还是在堆中。
  
28 泛型
泛型是在JDK1.5之后出现的。
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。
可以看到，使用 Object 来实现通用、不同类型的处理，有这么两个缺点：
1.每次使用时都需要强制转换成想要的类型
2.在编译时编译器并不知道类型转换是否正常，运行时才知道，不安全
根据《Java 编程思想》中的描述，泛型出现的动机在于：
有许多原因促成了泛型的出现，而最引人注意的一个原因，就是为了创建容器类。
实际上引入泛型的主要目标有以下几点：
1.类型安全 
1.泛型的主要目标是提高 Java 程序的类型安全
2.编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常
3.符合越早出错代价越小原则
2.消除强制类型转换 
1.泛型的一个附带好处是，使用时直接得到目标类型，消除许多强制类型转换
2.所得即所需，这使得代码更加可读，并且减少了出错机会
3.潜在的性能收益 
1.由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改
2.所有工作都在编译器中完成
3.编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已
泛型类 
泛型接口
泛型方法
泛型的通配符
无限制通配符
extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类
super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类
通配符比较
通过上面的例子我们可以知道，无限制通配符 < ?> 和 Object 有些相似，用于表示无限制或者不确定范围的场景。
两种有限制通配形式 < ? super E> 和 < ? extends E> 也比较容易混淆，我们再来比较下。
你了解泛型通配符与上下界吗？
ps：上下限用图说明
它们的目的都是为了使方法接口更为灵活，可以接受更为广泛的类型。
< ? super E> 用于灵活写入或比较，使得对象可以写入父类型的容器，使得父类型的比较方法可以应用于子类对象。
< ? extends E> 用于灵活读取，使得方法可以读取 E 或 E 的任意子类型的容器对象。
用《Effective Java》 中的一个短语来加深理解：
为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限：
PECS: producer-extends, costumer-super
因此使用通配符的基本原则：
如果参数化类型表示一个 T 的生产者，使用 < ? extends T>;
如果它表示一个 T 的消费者，就使用 < ? super T>；
如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。
小总结一下：
T 的生产者的意思就是结果会返回 T，这就要求返回一个具体的类型，必须有上限才够具体；
T 的消费者的意思是要操作 T，这就要求操作的容器要够大，所以容器需要是 T 的父类，即 super T；
泛型的类型擦除
Java 中的泛型和 C++ 中的模板有一个很大的不同：
C++ 中模板的实例化会为每一种类型都产生一套不同的代码，这就是所谓的代码膨胀。
Java 中并不会产生这个问题。虚拟机中并没有泛型类型对象，所有的对象都是普通类。
（摘自：blog.csdn.net/fw0124/arti…）
在 Java 中，泛型是 Java 编译器的概念，用泛型编写的 Java 程序和普通的 Java 程序基本相同，只是多了一些参数化的类型同时少了一些类型转换。
实际上泛型程序也是首先被转化成一般的、不带泛型的 Java 程序后再进行处理的，编译器自动完成了从 Generic Java 到普通 Java 的翻译，Java 虚拟机运行时对泛型基本一无所知。
当编译器对带有泛型的java代码进行编译时，它会去执行类型检查和类型推断，然后生成普通的不带泛型的字节码，这种普通的字节码可以被一般的 Java 虚拟机接收并执行，这在就叫做 类型擦除（type erasure）。
总结
1.上面说到使用 Object 来达到复用，会失去泛型在安全性和直观表达性上的优势，那为什么 ArrayList 等源码中的还能看到使用 Object 作为类型？
根据《Effective Java》中所述，这里涉及到一个 “移植兼容性”：
泛型出现时，Java 平台即将进入它的第二个十年，在此之前已经存在了大量没有使用泛型的 Java 代码。人们认为让这些代码全部保持合法，并且能够与使用泛型的新代码互用，非常重要。
这样都是为了兼容，新代码里要使用泛型而不是原始类型。
2.泛型是通过擦除来实现的。因此泛型只在编译时强化它的类型信息，而在运行时丢弃(或者擦除)它的元素类型信息。擦除使得使用泛型的代码可以和没有使用泛型的代码随意互用。
3.如果类型参数在方法声明中只出现一次，可以用通配符代替它。
比如下面的 swap 方法，用于交换指定 List 中的两个位置的元素：
private  void swap(List list, int i, int j) {
    //...
}
只出现了一次 类型参数，没有必要声明，完全可以用通配符代替：
private void swap(List list, int i, int j){
    //...
}
对比一下，第二种更加简单清晰吧。
4.数组中不能使用泛型
这可能是 Java 泛型面试题中最简单的一个了，当然前提是你要知道 Array 事实上并不支持泛型，这也是为什么 Joshua Bloch 在 《Effective Java》一书中建议使用 List 来代替 Array，因为 List 可以提供编译期的类型安全保证，而 Array 却不能。
5.Java 中 List 和原始类型 List 之间的区别?
原始类型和带参数类型 之间的主要区别是：
在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查
通过使用 Object 作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String 或 Integer
你可以把任何带参数的类型传递给原始类型 List，但却不能把 List< String> 传递给接受 List< Object> 的方法，因为泛型的不可变性，会产生编译错误。

29 请你谈谈如何通过反射创建对象？
- 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()
- 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance("Hello");
30 请说明Comparable和Comparator接口的作用以及它们的区别。
考察点：comparable接口
Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。
Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。
31 请你谈一下面向对象的"六原则一法则"。
考察点：Java对象
- 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是"高内聚"，写代码最终极的原则只有六个字"高内聚、低耦合"，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）
- 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）
- 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）
里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）
- 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）
- 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）
- 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。
调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。
请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？
参考回答：
Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。throw语句用来明确地抛出一个”异常”。throws用来标明一个成员函数可能抛出的各种”异常”。Finally为确保一段代码不管发生什么”异常”都被执行一段代码。可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，”异常“的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。
32.什么是Java异常
答：异常是发生在程序执行过程中阻碍程序正常执行的错误事件。比如：用户输入错误数据、硬件故障、网络阻塞等都会导致出现异常。只要在Java语句执行中产生了异常，一个异常对象就会被创建，JRE就会试图寻找异常处理程序来处理异常。如果有合适的异常处理程序，异常对象就会被异常处理程序接管，否则，将引发运行环境异常，JRE终止程序执行。 Java异常处理框架只能处理运行时错误，编译错误不在其考虑范围之内。
33.Java异常处理中有哪些关键字？
答：
· throw:有时我们需要显式地创建并抛出异常对象来终止程序的正常执行。throw关键字用来抛出并处理运行时异常。
· throws:当我们抛出任何“被检查的异常(checked exception)”并不处理时，需要在方法签名中使用关键字throws来告知调用程序此方法可能会抛出的异常。调用方法可能会处理这些异常，或者同样用throws来将异常传给上一级调用方法。throws关键字后可接多个潜在异常，甚至是在main()中也可以使用throws。
· try-catch:我们在代码中用try-catch块处理异常。当然，一个try块之后可以有多个catch子句，try-catch块也能嵌套。每个catch块必须接受一个（且仅有一个）代表异常类型的参数。
· finally:finally块是可选的，并且只能配合try-catch一起使用。虽然异常终止了程序的执行，但是还有一些打开的资源没有被关闭，因此，我们能使用finally进行关闭。不管异常有没有出现，finally块总会被执行。
若是某个方法可能发生异常，但不想在当前方法中处理这个异常，则可以使用throws、throw关键字在方法中抛出异常。
Throw和throws的区别
throws通常用在声明方法时，用来制指定可能抛出的异常。多个异常可以使用逗号分隔。
throw关键字通常用于方法体中，并且抛出一个异常对象。程序在执行到throw语句时立即终止，它后面的语句都不执行。通过throw抛出异常后，如果想在上一级代码中来捕获并处理异常，则需要在抛出异常的方法中使用throws关键字在方法的声明中指明要抛出的异常；如果要捕获throw抛出的异常，则必须使用try-catch语句块；
34.描述一下异常的层级。
答：Java异常是层级的，并通过继承来区分不同种类的异常。
· Throwable是所有异常的父类，它有两个直接子对象Error,Exception，其中Exception又被继续划分为“被检查的异常(checked exception)”和”运行时的异常（runtime exception,即不受检查的异常）”。 Error表示编译时和系统错误，通常不能预期和恢复，比如硬件故障、JVM崩溃、内存不足等。
· 被检查的异常（Checked exception）在程序中能预期，并要尝试修复，如FileNotFoundException。我们必须捕获此类异常，并为用户提供有用信息和合适日志来进行调试。Exception是所有被检查的异常的父类。
· 运行时异常（Runtime Exception）又称为不受检查异常，源于糟糕的编程。比如我们检索数组元素之前必须确认数组的长度，否则就可能会抛出ArrayIndexOutOfBoundException运行时异常。RuntimeException是所有运行时异常的父类。
java异常机制用户去考虑程序的强制性和安全性。异常处理不应用来控制程序的正常流程，其主要作用是捕获程序在运行时发生的异常并进行相应的处理。编写代码处理某个方法时可能出现的异常时，可遵循以下几条原则：

在当前方法声明中使用try-catch语句捕获异常。
在一个方法被覆盖时，覆盖它的方法必须抛出相应的异常或者异常的子类。
如果父类抛出多个异常，则覆盖的方法必须抛出那些异常的一个子集，不能抛出新的异常。
35 .try-catch-finally-return执行顺序？
不管是否有异常产生，finally块中代码都会执行
当try和catch中有return语句时，finally块仍然会执行
finally是在return后面的表达式运算执行的，所以函数返回值在finally执行前确定的，无论finally中的代码怎么样，返回的值都不会改变，仍然是之前return语句中保存的值
finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值
36 深拷贝 浅拷贝
浅拷贝 创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段进行复制，如果该字段是引用类型的话，则复制引用但不复制引用的对象，因此，原始对象及副本引用同一个对象。
深拷贝 不仅复制对象本身，而且复制对象包含的引用指向的所有对象。
将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。


37 IO NIO AIO
先来举个实例生活中的例子：
如果你想吃一份宫保鸡丁盖饭：
同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！
同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！
异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。
异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。

在弄清楚上面的几个问题之前，我们首先得明白什么是同步，异步，阻塞，非阻塞，只有这几个单个概念理解清楚了，然后在组合理解起来，就相对比较容易了。 

1,同步和异步是针对应用程序和内核的交互而言的。 

2,阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。  

由上描述基本可以总结一句简短的话，同步和异步是目的，阻塞和非阻塞是实现方式。 

1.同步：指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪。自己上街买衣服，自己亲自干这件事，别的事干不了。 

2.异步：异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知） 告诉朋友自己合适衣服的尺寸，大小，颜色，让朋友委托去卖，然后自己可以去干别的事。（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS） 

3.阻塞：所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止 去公交站充值，发现这个时候，充值员不在（可能上厕所去了），然后我们就在这里等待，一直等到充值员回来为止。（当然现实社会，可不是这样，但是在计算机里确实如此。） 

4.非阻塞：非阻塞状态下, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待， 银行里取款办业务时，领取一张小票，领取完后我们自己可以玩玩手机，或者与别人聊聊天，当轮我们时，银行的喇叭会通知，这时候我们就可以去了。

一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作。 
同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO。 

阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。 

同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。

而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。 

所以,IO操作可以分为3类：同步阻塞（即早期的BIO操作）、同步非阻塞（NIO）、异步非阻塞（AIO）。 

同步阻塞(BIO)： 
在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式。 
同步非阻塞(NIO)：
在此种方式下，用户进程发起一个IO操作以后便可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。 
异步非阻塞(AIO)：
此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。

同步阻塞IO（JAVA BIO）： 
同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 
IO的局限：IO是面向流的，阻塞式的，串行的一个过程。对每一个客户端的socket连接，IO都需要一个线程来处理，而且在此期间，这个线程一直被占用，直到socket关闭。在这期间，tcp的连接、数据的读取、数据的返回都是被阻塞的。也就是说这期间大量的浪费了cpu的时间片和线程占用的内存资源。
每建立一个Socket连接时，同时创建一个新线程对该Socket进行单独通信（采用阻塞的方式通信）。这种方式具有很高的响应速度，并且控制起来也很 简单，在连接数较少的时候非常有效，但是如果对每一个连接都产生一个线程的无疑是对系统资源的一种浪费，如果连接数较多将会出现资源不足的情况。
同步非阻塞IO(Java NIO)：
同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。 
NIO则是面向缓冲区的，非阻塞式的，基于选择器的，用一个线程来轮询监控多个数据传输通道，哪个通道准备好了（即有了一组可以处理的数据），就处理哪个通道。
服务器端保存一个Socket连接列表，然后对这个列表进行轮询，如果发现某个Socket端口上有数据可读时（读就绪），则调用该socket连接的相 应读操作；如果发现某个 Socket端口上有数据可写时（写就绪），则调用该socket连接的相应写操作；如果某个端口的Socket连接已经中断，则调用相应的析构方法关闭 该端口。这样能充分利用服务器资源，效率得到了很大提高。

Selector类是NIO的核心类，Selector能够检测多个注册的通道上是否有事发生，如果有事发生，便获取事件然后针对每个事件进行相应的响应处理，这样一来，只用一个单线程便可以管理多个连接，只要在连接真正有读写 事件发生的时候，才会调用函数进行读写，大大减少了系统开销，并且不必为每个连接创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换带来的开销。

异步阻塞IO（Java NIO）：  
此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！  


（Java AIO(NIO.2)）异步非阻塞IO:  
在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。  
异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，每个线程不必亲自处理io，而是委派os来处理，并且也不需要等待io完成了，如果完成后，os会通知的。
BIO、NIO、AIO适用场景分析: 
        BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 
        NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 
        AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 
Epoll和poll，select的区别
文件描述符fd；文件描述符是一个索引号，是一个非负整数，它指向普通的文件或者I/O设备，它是连接用户空间和内核空间纽带。在linux系统上内核（kernel）利用文件描述符（file descriptor）来访问文件。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。（在Windows系统上，文件描述符被称作文件句柄）
I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。select，poll，epoll都是IO多路复用的机制。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。下来，分别谈谈。
select——>
原理概述：
select 的核心功能是调用tcp文件系统的poll函数，不停的查询，如果没有想要的数据，主动执行一次调度（防止一直占用cpu），直到有一个连接有想要的消息为止。从这里可以看出select的执行方式基本就是不同的调用poll,直到有需要的消息为止。
缺点：
1、每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；
2、同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大；
3、select支持的文件描述符数量太小了，默认是1024。
优点：
1、select的可移植性更好，在某些Unix系统上不支持poll()。
2、select对于超时值提供了更好的精度：微秒，而poll是毫秒。
poll——>
原理概述：
poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。
缺点：
1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义；
2、与select一样，poll返回后，需要轮询pollfd来获取就绪的描述符。
优点：
1、poll() 不要求开发者计算最大文件描述符加一的大小。
2、poll() 在应付大数目的文件描述符的时候速度更快，相比于select。
3、它没有最大连接数的限制，原因是它是基于链表来存储的。
epoll——>
原理概述：
epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时， 返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一 个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射技术，这 样便彻底省掉了这些文件描述符在系统调用时复制的开销。
epoll的优点就是改进了前面所说缺点：
1、支持一个进程打开大数目的socket描述符：相比select，epoll则没有对FD的限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。
2、IO效率不随FD数目增加而线性下降：epoll不存在这个问题，它只会对"活跃"的socket进行操作— 这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有"活跃"的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个"伪"AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的—比如一个高速LAN环境，epoll并不比select/poll有什么效率，相 反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。
3、使用mmap加速内核与用户空间的消息传递：这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就 很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。
三者对比与区别：
1、select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。
2、select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。

38 Uml统一建模语言
统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言。UML使用面向对象设计的建模工具，但独立于任何具体程序设计语言。
作用：
(1)为软件系统建立可视化模型。
(2)为软件系统建立构件。
(3)为软件系统建立文档。
UML系统开发中有三个主要的模型： 
功能模型：从用户的角度展示系统的功能，包括用例图
对象模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图。
动态模型：展现系统的内部行为。包括序列图，活动图，状态图。 
40 自动拆箱装箱的场景
这8种基本数据类型的变量不需要使用new来创建，它们不会在堆上创建，而是直接在栈内存中存储，因此会比使用对象更加高效。
但是，在某些时候，基本数据类型会有一些制约，例如当有个方法需要Object类型的参数，但实际需要的值却是2、3等数值，这就比较难以处理了。因为，所有引用类型的变量都继承了Object类，都可当成Object类型变量使用，但基本数据类型的变量就不可以了。
为了解决这个问题，Java为这8种基本数据类型分别定义了相应的引用类型，并称之为基本数据类型的包装类（Wrapper Class）。包装类均位于java.lang包下，其和基本数据类型的对应关系如下表所示：

所谓自动装箱，就是自动将基本数据类型转换为包装器类型；自动拆箱，就是自动将包装器类型转换为基本数据类型


自动装箱，都是通过包装类的valueOf()方法来实现的。
自动拆箱，都是通过包装类对象的xxxValue()来实现的。
39 谈一谈，id全局唯一且自增，如何实现？
考察点：SnowFlake雪花算法
参考回答；
SnowFlake雪花算法
雪花ID生成的是一个64位的二进制正整数，然后转换成10进制的数。64位二进制数由如下部分组成：
snowflake id生成规则
1位标识符：始终是0，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0。
41位时间戳：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的。
10位机器标识码：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成。
12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号
优点
简单高效，生成速度快。
时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增。
灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求。
缺点
依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成。
在分布式环境上，每个服务器的时钟不可能完全同步，有时会出现不是全局递增的情况。
41 Integer的缓存机制
有如下代码，你知道输出结果是什么吗？
public static void main(String[] args) {
    Integer a = 1;
    Integer b = 1;
    Integer c = 128;
    Integer d = 128;
    System.out.println(a == b);
    System.out.println(c == d);
}

我们都知道在Java里，当用==来比较两个对象时，比较的是地址，如果两个对象引用指向堆中的同一块内存就返回true，否则返回false。这一点是完全正确的。
那按照这个理论，上面代码应该输出都是false，因为4个变量都是Integer类型的对象，但实际输出结果却是这样的：
truefalse

这让人疑惑：同样是两个int类型的数值自动装箱成Integer对象，如果是两个2自动装箱后就相等；但如果是两个128自动装箱后就不相等，这是为什么呢？
一起来找下这个问题的答案：
1.Integer a = 1，根据前文我们知道，这里发生了自动装箱，而自动装箱其实就是调用了Integer的valueOf方法
2.既然调用了这个valueOf方法，那我们是不是应该去看看这个方法里到底做了什么事情？
3.最后去查看Integer这个包装类的valueOf的具体实现。
来，一起来看JDK里valueOf方法的源代码：
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}

方法实现很简单，先解释一下，IntegerCache是Integer类中定义的一个private static的内部类，它维护了一个Integer数组cache，IntegerCache源码如下：
IntegerCache类有一个int类型的常量low，值为-128
还有一个int类型的常量high，它的值通过静态初始化块进行赋值，默认为127（从javadoc可以看到，这个值可以通过虚拟机参数：-XX:AutoBoxCacheMax=进行设置）
最后，还有一个Integer类型的数组cache[]，它同样通过静态初始化块进行初始化，长度==(high - low) + 1，默认为（127+128+1）=256，数组元素值为-128~127。
ps：大佬们写的代码真的是太优雅了！！
我们终于找到上面问题的答案了：
Integer类初始化时，会把一个-128127之间的Integer类型对象放入一个名为cache的数组中**缓存**起来。如果以后把一个-128127之间的基本数据类型自动装箱成一个Integer实例时（即调用valueOf方法）,实际上是直接引用了cache数组中的对应元素。但每次把一个不在-128~127范围内的整数自动装箱成Integer实例时，就需要重新new一个Integet实例，所以出现了上面那样的运行结果。
缓存是一种非常优秀的设计模式，在Java、JavaEE平台的很多地方都会通过缓存来提高系统的性能。
类型的，Byte、Short、Long、Character也有相同的缓存机制，值得注意的是Double、Float是没有缓存机制的。有兴趣的同学，可以自行查看源码。
1.装箱操作会创建对象，频繁的装箱操作会消耗许多内存，影响性能，所以可以避免装箱的时候应该尽量避免。
2.有些场景会进行自动拆装箱，此时要注意包装类对象是否为null，否则自动拆箱时就有可能抛出NPE。
3.包装对象的数值比较，不能简单的使用==，虽然-128到127之间的数字可以，但是这个范围之外还是需要使用equals比较。
42 请列举你所知道的Object类的方法并简要说明。
Object()默认构造方法。
clone() 创建并返回此对象的一个副本。
equals(Object obj) 指示某个其他对象是否与此对象“相等”。
finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
getClass()返回一个对象的运行时类。
hashCode()返回该对象的哈希码值。 
notify()唤醒在此对象监视器上等待的单个线程。 
notifyAll()唤醒在此对象监视器上等待的所有线程。
toString()返回该对象的字符串表示。
wait()导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。
wait(long timeout)导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。
43 创建对象的4种方式
1.使用new创建对象
　　使用new关键字创建对象应该是最常见的一种方式，但我们应该知道，使用new创建对象会增加耦合度。无论使用什么框架，都要减少new的使用以降低耦合度。

2.使用反射的机制创建对象
 使用Class类的newInstance方法
Java实现缓存
Hello类的代码不变，NewClass类的代码如下：
 使用Constructor类的newInstance方法

3.采用clone
　　clone时，需要已经有一个分配了内存的源对象，创建新对象时，首先应该分配一个和源对象一样大的内存空间。
要调用clone方法需要实现Cloneable接口，由于clone方法是protected的，所以修改Hello类。

4.采用序列化机制
使用序列化时，要实现实现Serializable接口，将一个对象序列化到磁盘上，而采用反序列化可以将磁盘上的对象信息转化到内存中。

44 Java实现缓存
一、什么是缓存？
　　缓存，就是将程序或系统经常要调用的对象存在内存中，以便其使用时可以快速调用，不必再去创建新的重复的实例。这样做可以减少系统开销，提高系统效率。
二、缓存的实现方式：
　　实现方式1：
　　内存缓存，也就是实现一个类中静态Map,对这个Map进行常规的增删查.。
实现方式2（使用spring支持的cache）：
　 实现步骤：　
　　第一步： 导入spring-boot-starter-cache模块
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
       第二步： @EnableCaching开启缓存
@SpringBootApplication
@EnableCachingpublic class Springboot07CacheApplication {

   public static void main(String[] args) {
      SpringApplication.run(Springboot07CacheApplication.class, args);
   }
}
       第三步： 使用缓存注解
     UserInfoCacheController

45 Java常用的包
第一个包：java.lang包。
该包提供了Java语言进行程序设计的基础类，它是默认导入的包。该包里面的Runnable接口和Object、Math、String、StringBuffer、System、Thread以及Throwable类需要重点掌握，因为它们应用很广。
第二个包：java.util包。
该包提供了包含集合框架、遗留的集合类、事件模型、日期和时间实施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。
第三个包：java.io包。
该包通过文件系统、数据流和序列化提供系统的输入与输出。
第四个包：java.net包。
该包提供实现网络应用与开发的类。
第五个包：java.sql包。
该包提供了使用Java语言访问并处理存储在数据源（通常是一个关系型数据库）中的数据API。
第六个包：java.awt包
该包包含了构成抽象窗口工具集(abstract window toolkits)的多个类,这些类被用来构建和管理应用程序的图形用户界面(GUI)。
第七个包：javax.swing包。
这两个包提供了GUI设计与开发的类。java.awt包提供了创建界面和绘制图形图像的所有类，而javax.swing包提供了一组“轻量级”的组件，尽量让这些组件在所有平台上的工作方式相同。
46 一个java对象有多大
　我们怎么知道一个java对象的大小呢？比如HashMap<String,Object> map = new HashMap<>();,这个map对象在堆中多大呢？占多少个字节呢？
我们可以看到最后计算出来的一个Integer是16个字节，一个HashMap是48个字节；
这个时候肯定会有人说，凸不对呀，不是说int类型是4个字节的吗？为什么包装类型Integer的就是16个字节了呢？

要知道这个问题，首先我们要知道在java堆中实例化的对象是由什么构成的？前面博客说了的，这里简单的提一下，分三部分：对象头，实例数据，对齐填充
我们再说说那么HashMap，对象头也是12，实例数据，我们要看看HashMap的父类有两个属性，是引用类型，每一个占4个字节；
再看看HashMap本类中有几个属性，可以看到6个，共占24个字节
所以就是12+4+4+24=44，由于java对象占的字节数必须要是8的倍数，所以对齐填充，在最后补4个字节，所以总共就是48个字节，很容易吧！
new一个对象的过程
  在语言层面创建对象（例如克隆、反序列化）通常仅仅是一个new关键字而已，而在虚拟机中，对象（普通Java对象，不包括数组和Class对象等）的创建时一个怎么样的过程？

一、对象的创建
    当虚拟机遇到一条new指令时候，首先去检查这个指令的参数是否能在常量池中能否定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

    在类加载检查通过后，接下来虚拟机将为新生的对象分配内存。对象所需的内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来，目前常用的有两种方式：

    1.指针碰撞（Bump the Pointer）：假设Java堆的内存是绝对规整的，所有用过的内存都放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间那边挪动一段与对象大小相等的距离。

    2.空闲列表（Free List）：如果Java堆中的内存并不是规整的，已使用的内存和空间的内存是相互交错的，虚拟机必须维护一个空闲列表，记录上哪些内存块是可用的，在分配时候从列表中找到一块足够大的空间划分给对象使用。

    除了如何划分可用空间外，在并发情况下划分不一定是线程安全的，有可能出现正在给A对象分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针分配内存的情况，解决这个问题两种方案：

    1.分配内存空间的动作进行同步处理：实际上虚拟机采用CAS配上失败重试的方式保证了更新操作的原子性。

    2.内存分配的动作按照线程划分在不同的空间中进行：为每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。

    内存分配完后，虚拟机需要将分配到的内存空间中的数据类型都初始化为零值（不包括对象头）；接下来虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都存放在对象的对象头中。做完以上以后，从虚拟机视角来看，一个新的对象已经产生了，但是Java程序视角来看，执行new操作后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正的对象就产生了。

二、对象的内存布局
    在HotSpot虚拟机中，对象在内存中的存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）.

（一）对象头
    1.第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称为“Mark Word”。

    2.类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象的哪个实例。

（二）实例数据
    1.对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。

（三）对齐填充
    1.对齐填充不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。

三、对象的访问定位
   建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流访问方式有使用句柄和直接指针两种：

（一）句柄访问
Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象句柄位置，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

（二）直接指针访问
如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。


47 linkedlist add offer
 offer属于 offer in interface Deque<E>，add 属于 add in interface Collection<E>。   
   当队列为空时候，使用add方法会报错，而offer方法会返回false。
   作为List使用时,一般采用add / get方法来 压入/获取对象。  remove
   作为Queue使用时,才会采用 offer/poll/take等方法作为链表对象时,offer等方法相对来说没有什么意义这些方法是用于支持队列应用的。
1. add() 和 offer() 的区别
add() 和 offer() 都是向队列中添加一个元素 . 一些队列有大小限制,因此如果想在已满的队列加入一个新队列, 调用 add() 方法就会抛出一个 unchecked 异常, 而调用 offer() 方法返回 flase . 因此就可以在程序中进行有效的判断 .

2. poll() 和 remove() 的区别
poll() 和 remove() 方法都是从队列中删除第一个元素. 如果队列元素为空 ,调用 remove() 的行为与 Collection 接口的版本相似会抛出异常 . 但是新的 poll() 方法会在用空集合调用时只会返回 null . 因此新的方法更适合容易出现异常条件的情况.

3. element() 和 peek() 的区别
element() 和 peek()用于在队列的头部查询元素. 与 remove() 方法类似 , 在队列为空时 , element () 抛出一个异常 , 而 peek()返回 null .
48 序列化和反序列化的底层实现原理是什么？
一、基本概念
1、什么是序列化和反序列化
　（1）Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程；
　（2）**序列化：**对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。
　（3）**反序列化：**客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。
　（4）本质上讲，序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。
 
2、为什么需要序列化与反序列化
　　我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。
　　那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？答案是可以的！如何做到呢？这就需要Java序列化与反序列化了！
　　换句话说，一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。
　　当我们明晰了为什么需要Java序列化和反序列化后，我们很自然地会想Java序列化的好处。其好处一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。
总的来说可以归结为以下几点：
（1）永久性保存对象，保存对象的字节序列到本地文件或者数据库中；
（2）通过序列化以字节流的形式使对象在网络中进行传递和接收；
（3）通过序列化在进程间传递对象；
 
3、序列化算法一般会按步骤做如下事情：
（1）将对象实例相关的类元数据输出。
（2）递归地输出类的超类描述直到不再有超类。
（3）类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。
（4）从上至下递归输出实例的数据
 
二、Java如何实现序列化和反序列化
1、JDK类库中序列化和反序列化API
（1）java.io.ObjectOutputStream：表示对象输出流；
　　它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中；
（2）java.io.ObjectInputStream：表示对象输入流；
　　它的readObject()方法源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回；
 
2、实现序列化的要求
　　只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！
 
3、实现Java对象序列化与反序列化的方法
假定一个User类，它的对象需要序列化，可以有如下三种方法：
（1）若User类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化
　　ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。
　　ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。
（2）若User类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。
　　ObjectOutputStream调用User对象的writeObject(ObjectOutputStream out)的方法进行序列化。
　　ObjectInputStream会调用User对象的readObject(ObjectInputStream in)的方法进行反序列化。
（3）若User类实现了Externalnalizable接口，且User类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。
　　ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化。
　　ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化。
 
4、JDK类库中序列化的步骤
步骤一：创建一个对象输出流，它可以包装一个其它类型的目标输出流，如文件输出流：
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("D:\\object.out"));
步骤二：通过对象输出流的writeObject()方法写对象：
oos.writeObject(new User("xuliugen", "123456", "male"));
 
5、JDK类库中反序列化的步骤
步骤一：创建一个对象输入流，它可以包装一个其它类型输入流，如文件输入流：
ObjectInputStream ois= new ObjectInputStream(new FileInputStream("object.out"));
步骤二：通过对象输出流的readObject()方法读取对象：
User user = (User) ois.readObject();
说明：为了正确读取数据，完成反序列化，必须保证向对象输出流写对象的顺序与从对象输入流中读对象的顺序一致。
三、相关注意事项
　1、序列化时，只对对象的状态进行保存，而不管对象的方法；
　2、当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；
　3、当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；
　4、并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：
　　安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；
　　资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；
　5、声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。
　6、序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：
　　在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；
　　在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。
　7、Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的；
　8、如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因；
49 java如何储存超大的数？

50 restful编程风格
概念
         一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。

 

URL定义
资源：互联网所有的事物都可以被抽象为资源 
资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 
分别对应 添加、 删除、修改、查询。 


传统方式操作资源 
http://127.0.0.1/item/queryUser.action?id=1   查询,GET 
http://127.0.0.1/item/saveUser.action             新增,POST 
http://127.0.0.1/item/updateUser.action          更新,POST 
http://127.0.0.1/item/deleteUser.action?id=1  删除,GET或POST

 

请求方式
可以通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。其中，GET 用于查询资源，POST 用于创建资源，PUT 用于更新服务端的资源的全部信息，PATCH 用于更新服务端的资源的部分信息，DELETE 用于删除服务端的资源。

这里使用“用户”的案例进行回顾通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。

 

使用RESTful操作资源 
【GET】 /users # 查询用户信息列表

【GET】 /users/1001 # 查看某个用户信息

【POST】 /users # 新建用户信息

【PUT】 /users/1001 # 更新用户信息(全部字段)

【PATCH】 /users/1001 # 更新用户信息(部分字段)

【DELETE】 /users/1001 # 删除用户信息

之前的操作是没有问题的,大神认为是有问题的,有什么问题呢?你每次请求的接口或者地址,都在做描述,例如查询的时候用了queryUser,新增的时候用了saveUser ，修改的时候用了updateUser,其实完全没有这个必要,我使用了get请求,就是查询.使用post请求,就是新增的请求,PUT就是修改，delete就是删除，我的意图很明显,完全没有必要做描述,这就是为什么有了restful.

 
API设计风格基本规则
1.使用名词而不是动词
不要使用：

/getAllUsers
/createNewUser
/deleteAllUser

2.Get方法和查询参数不应该涉及状态改变
使用PUT, POST 和DELETE 方法 而不是 GET 方法来改变状态，不要使用GET 进行状态改变:

3.使用复数名词
不要混淆名词单数和复数，为了保持简单，只对所有资源使用复数。

/cars 而不是 /car
/users 而不是 /user
/products 而不是 /product
/settings 而部署 /setting

4. 使用子资源表达关系
如果一个资源与另外一个资源有关系，使用子资源：

GET /cars/711/drivers/ 返回 car 711的所有司机
GET /cars/711/drivers/4 返回 car 711的4号司机

5.使用Http头声明序列化格式
在客户端和服务端，双方都要知道通讯的格式，格式在HTTP-Header中指定

Content-Type 定义请求格式
Accept 定义系列可接受的响应格式

6.为集合提供过滤 排序 选择和分页等功能
Filtering过滤:

使用唯一的查询参数进行过滤：

GET /cars?color=red 返回红色的cars
GET /cars?seats<=2 返回小于两座位的cars集合

Sorting排序:

允许针对多个字段排序

GET /cars?sort=-manufactorer,+model

这是返回根据生产者降序和模型升序排列的car集合

Field selection

移动端能够显示其中一些字段，它们其实不需要一个资源的所有字段，给API消费者一个选择字段的能力，这会降低网络流量，提高API可用性。

GET /cars?fields=manufacturer,model,id,color

Paging分页

使用 limit 和offset.实现分页，缺省limit=20 和offset=0；

GET /cars?offset=10&limit=5

为了将总数发给客户端，使用订制的HTTP头： X-Total-Count.

链接到下一页或上一页可以在HTTP头的link规定，遵循Link规定:

Link: <https://blog.mwaysolutions.com/sample/api/v1/cars?offset=15&limit=5>; rel="next",
<https://blog.mwaysolutions.com/sample/api/v1/cars?offset=50&limit=3>; rel="last",
<https://blog.mwaysolutions.com/sample/api/v1/cars?offset=0&limit=5>; rel="first",
<https://blog.mwaysolutions.com/sample/api/v1/cars?offset=5&limit=5>; rel="prev",

7.版本化你的API
使得API版本变得强制性，不要发布无版本的API，使用简单数字，避免小数点如2.5.

一般在Url后面使用?v

/blog/api/v1

8. 使用Http状态码处理错误
如果你的API没有错误处理是很难的，只是返回500和出错堆栈不一定有用

Http状态码提供70个出错，我们只要使用10个左右：

200 – OK – 一切正常
201 – OK – 新的资源已经成功创建
204 – OK – 资源已经成功擅长

304 – Not Modified – 客户端使用缓存数据

400 – Bad Request – 请求无效，需要附加细节解释如 "JSON无效"
401 – Unauthorized – 请求需要用户验证
403 – Forbidden – 服务器已经理解了请求，但是拒绝服务或这种请求的访问是不允许的。
404 – Not found – 没有发现该资源
422 – Unprocessable Entity – 只有服务器不能处理实体时使用，比如图像不能被格式化，或者重要字段丢失。

500 – Internal Server Error – API开发者应该避免这种错误。

使用详细的错误包装错误：

{

  "errors": [

   {

    "userMessage": "Sorry, the requested resource does not exist",

    "internalMessage": "No car found in the database",

    "code": 34,

    "more info": "http://dev.mwaysolutions.com/blog/api/v1/errors/12345"

   }

  ]

}

9.允许覆盖http方法
一些代理只支持POST 和 GET方法， 为了使用这些有限方法支持RESTful API，需要一种办法覆盖http原来的方法。

使用订制的HTTP头 X-HTTP-Method-Override 来覆盖POST 方法.
